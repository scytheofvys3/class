# Объектно-ориентированное программирование (ООП) основывается на трёх ключевых принципах:
# 1) Наследование — этот принцип позволяет создавать новые классы на основе существующих,
# что даёт возможность расширять и изменять поведение базового класса, делая производные классы более уникальными.
# 2) Инкапсуляция — позволяет скрывать внутренние детали реализации класса от пользователей,
# предоставляя доступ только к необходимым элементам. Это способствует более безопасной работе и предотвращает случайные ошибки.
# 3) Полиморфизм — позволяет использовать объекты разных классов через единый интерфейс,
# что упрощает взаимодействие с ними и делает код более гибким.
'''Дополнительное объяснение:'''
from gevent.subprocess import value


# Что такое класс?
# Класс — это конструкция, которая описывает структуру и поведение объектов. Он содержит:
#
# Атрибуты — данные или свойства объекта (например, name).
# Методы — функции, которые определяют поведение объекта.
# Что такое объект?
# Объект (или экземпляр класса) — это конкретный "представитель" класса с уникальным набором атрибутов. В данном примере Ilya и Alina — это два разных объекта класса Human.
#
# Что делает __init__?
# __init__ (инициализатор) автоматически вызывается при создании нового объекта. Он помогает задать начальные значения атрибутов, используя аргументы, переданные при создании объекта.
#
# Почему используется self?
#
# self — это ссылка на текущий объект, который создаётся.
# Все атрибуты и методы объекта доступны через self.
# В инициализаторе self.name = name означает: "Создать атрибут name у текущего объекта и присвоить ему значение из аргумента name."
# Для создания класса достаточно указать ключевое слово class, после которого следует название класса (с большой буквы).

# Класс можно представить как шаблон или инструкцию, на основе которой создаются объекты (экземпляры).
# Каждый объект класса обладает характеристиками (атрибутами) и может выполнять определённые действия (методы).
# Классы позволяют объединять данные (атрибуты) и логику (методы) в одной структуре.

class Human:
    # Инициализатор класса (__init__) — это специальный метод, который вызывается автоматически при создании нового объекта.
    # Он используется для задания начальных значений атрибутов объекта.
    def __init__(self, name, age):
        """Здесь обычно идет описание класса в тройных кавычках"""
        # self — ссылка на текущий экземпляр объекта. Она позволяет обращаться к атрибутам и методам объекта.
        # Атрибуты name и age инициализируются при создании объекта. Они становятся уникальными характеристиками каждого объекта.
        self.name = name # Устанавливаем значение атрибута name.
        self.age = age # Устанавливаем значение атрибута age.
        self.say_info()  # Вызов метода внутри конструктора (__init__). Это позволяет автоматически выводить информацию о созданном объекте.

    # Метод объекта, который выводит информацию об объекте в формате строки.
    def say_info(self):
        # self.name и self.age относятся к текущему экземпляру класса.
        print(f'Привет, меня зовут {self.name}, мне {self.age}')

    # Метод объекта, который увеличивает значение атрибута age на 1.
    def birthday(self): # метод при котором, использовании этого метода увеличивается возраст объекта/экземпляра
        self.age += 1 # Увеличиваем значение возраста (age) текущего объекта.
        print(f'У меня день рождения, мне теперь {self.age}')

    # Методы, содержащие двойное подчеркивание, называются специальными или магическими методами.
    # Также можно встретить другое название — dunder-методы, что является сокращением от фразы "double underscore"
    # (двойное нижнее подчеркивание). На данном занятии будет представлено несколько из этих магических методов.

    # Использование метода __len__() для определения длины массива в Python.
    # Метод __len__ всегда должен возвращать int
    def __len__(self):
        return self.age

    # destruct - деструктор
    # Это может происходить либо по завершении работы интерпретатора, когда все строки кода выполнены, либо при отсутствии ссылок на объект.
    # Для удаления объекта можно воспользоваться оператором '__del__', который активирует деструктор.
    def __del__(self):
        print(f'{self.name} ушел(а), но обещал(а) вернуться')

    # Переопределение метода __bool__ позволяет задавать собственные условия для проверки "истинности" объектов класса.
    # В данном случае объект считается "истинным", если значение его атрибута age больше 18.

    # Метод __bool__ вызывается автоматически, когда объект участвует в условной проверке (например, if <объект>:).
    # Возвращаемое значение — True или False:
    # - True, если age > 18.
    # - False, если age <= 18.
    def __bool__(self):
        return self.age > 18

    # В Python существуют встроенные операторы (например, +, -, >, <, ==), которые имеют стандартное поведение для базовых типов данных.
    # Например:
    # - Числа: 5 > 3 вернёт True, а 7 < 2 вернёт False.
    # - Строки: "apple" < "banana" (лексикографическое сравнение).
    #
    # Однако мы можем переопределить стандартное поведение операторов для объектов пользовательских классов.
    # Этот процесс называется **перегрузкой операторов**.
    #
    # Это позволяет определять, как операторы работают с экземплярами классов, предоставляя свою логику.

    # Перегрузка оператора "<" (меньше чем).
    # Метод '__lt__()' (Lower Than) определяет, что должно происходить при использовании оператора "<" для объектов данного класса.
    # В данном примере: два объекта будут сравниваться на основе их атрибута 'age'.
    def __lt__(self, other):
        return self.age < other.age

    # Перегрузка оператора ">" (больше чем).
    # Метод '__gt__()' (Greater Than) определяет, что должно происходить при использовании оператора ">" для объектов данного класса.
    # В данном примере: два объекта будут сравниваться на основе их атрибута 'age'
    def __gt__(self, other):
        return self.age > other.age

    # Перезагрузка оператора "==" (равно).
    # Метод '__eq__()' (Equal) определяет, что должно происходить при использовании оператора "==" для объектов данного класса.
    # В данном примере: два объекта будут сравниваться на основе их атрибутов name == name и age == age
    def __eq__(self, other):
        return self.name == other.name and self.age == other.name


# ilya — это экземпляр (объект) класса Human.
# Переменная ilya — это объект (экземпляр) класса Human, созданный на основе его шаблона.
# Класс Human — это шаблон, описывающий свойства и поведение человека (атрибуты и методы).

# Чтобы создать объект, вы вызываете класс как функцию
# Создаём объект класса Human с именем 'Илья' и возрастом 24.
ilya = Human('Илья', 24)
# Переменная ilya представляет собой экземпляр класса Human и хранит информацию о конкретном человеке.

# Можно добавить атрибут объекту после его создания, даже если он не был определён в классе.
ilya.surname = 'Нефедов'

# Создаём второй объект класса Human с именем 'Алина' и возрастом 24.
alina = Human('Алина', 24)
liza = Human('Лиза', 13)

# Выводим значения атрибутов объектов.
# Атрибут name хранит имя объекта, age — возраст, а surname был добавлен вручную для объекта ilya.
print(ilya.name, ilya.surname, ilya.age)
print(alina.name, alina.age)

# Функция hasattr() проверяет существование атрибута в указанном объекте.
if hasattr(ilya, 'surname'):
    print(f'{ilya.surname}, Проверка функции hasattr')
else:
    print("У объекта нет атрибута surname.")

# Применяем метод birthday для объекта alina, чтобы увеличить её возраст на 1.
alina.birthday()

'''del ilya # при добавлении деструктора мы можем удалять объект через оператор del'''

# Вновь выводим информацию об объектах, используя метод say_info.
ilya.say_info()
alina.say_info()

print(ilya < alina)
print(ilya > alina)
print(ilya == alina)

# При проверке if <переменная>: вызывается метод __bool__() объекта, на который ссылается переменная.
# Если метод возвращает True, код внутри блока if выполняется.
# Если метод возвращает False, выполняется блок else (если он есть)

# if ilya:  # Проверяем объект ilya. Метод ilya.__bool__() возвращает True или False в зависимости от возраста.
# Если ilya.age > 18, выполнится код в блоке if.
# Если ilya.age <= 18, выполнится блок else.

if ilya:
    print(f'{ilya.name} достиг совершеннолетия')
else:
    print(f'{ilya.name} не достиг совершеннолетия')
# Поведение аналогично: if alina: и if liza: проверяют истинность объектов.
# Метод __bool__ для каждого объекта (alina, liza) вызывает соответствующий атрибут age объекта
if alina:
    print(f'{alina.name} достиг совершеннолетия')
else:
    print(f'{alina.name} не достиг совершеннолетия')
# Вывод информации о совершеннолетии каждого объекта:
# - Если объект "истинный" (возраст больше 18), выводится сообщение о достижении совершеннолетия.
# - Если объект "ложный" (возраст 18 или меньше), выводится сообщение о несовершеннолетии.
if liza:
    print(f'{liza.name} достиг совершеннолетия')
else:
    print(f'{liza.name} не достигла совершеннолетия')


# DZ 21
class House: # создаем класс дома
    def __init__(self, name, number_of_floors): # инициализация. self - ссылка на саму себя, атрибуты: name - название, number_of_floors - номер этажа
        self.name = name # устанавливаем значение атрибута name = name
        self.number_of_floors = number_of_floors # устанавливаем значение атрибута number_of_floors = number_of_floors

    def go_to(self, new_floor): # метод в классе
        if new_floor > self.number_of_floors or new_floor < 1: # Если new_floor больше чем self.number_of_floors или меньше 1
            return print('Такого этажа не существует') # возвращаем Такого этажа не существует
        else: # иначе
            for i in range(1, new_floor + 1): # для(for) i в(in) range(1, new_floor + 1)
                                              # range(start, stop, step) - stop не включительный
                print (i)

    def __len__(self): # метод __len__ возвращает длину массива, всегда int
        return self.number_of_floors # возвращаем номер/длину этажей

    # Перегрузка оператора "str()" (представление объекта в виде строки).
    # Метод __str__ является специальным методом, предназначенным для представления строкового представления объекта.
    # Метод '__str__()' определяет, как объект будет выглядеть при вызове функции str() или print().
    def __str__(self):
        return f'Название: {self.name}, кол-во этажей {self.number_of_floors}'

    # Перезагрузка оператора "==" (равно).
    # Метод '__eq__()' (Equal) определяет, что должно происходить при использовании оператора "==" для объектов данного класса.
    # В данном примере: два объекта будут сравниваться на основе их атрибутов number_of_floors == number_of_floors
    # Функция isinstance() используется для проверки принадлежности объекта к определенному классу или типу данных.
    ## isinstance - (объект, (тип данных)) - выдает true(истина) или false(ложь)
    def __eq__(self, other):
        if isinstance(other, House):
            return self.number_of_floors == other.number_of_floors

    # Перегрузка оператора "<" (меньше чем).
    # Метод '__lt__()' (Lower Than) определяет, что должно происходить при использовании оператора "<" для объектов данного класса.
    # В данном примере: два объекта будут сравниваться на основе их атрибута 'age'
    def __lt__(self, other):
        if isinstance(other, House):
            return self.number_of_floors < other.number_of_floors

    # Перегрузка оператора "<=" (меньше или равно).
    # Метод '__le__()' (Lower or Equal) определяет, что должно происходить при использовании оператора "<=".
    # В данном примере: проверяется, меньше или равен атрибут 'age' у одного объекта по сравнению с другим.
    def __le__(self, other):
        if isinstance(other, House):
            return self.number_of_floors <= other.number_of_floors

    # Перегрузка оператора ">" (больше чем).
    # Метод '__gt__()' (Greater Than) определяет, что должно происходить при использовании оператора ">".
    # В данном примере: два объекта сравниваются на основе их атрибута 'number_of_floors', проверяя, больше ли он.
    def __gt__(self, other):
        if isinstance(other, House):
            return self.number_of_floors > other.number_of_floors

    # Перегрузка оператора ">=" (больше или равно).
    # Метод '__ge__()' (Greater or Equal) определяет, что должно происходить при использовании оператора ">=".
    # В данном примере: проверяется, больше или равен атрибут 'number_of_floors' у одного объекта по сравнению с другим.
    def __ge__(self, other):
        if isinstance(other, House):
            return self.number_of_floors >= other.number_of_floors

    # Перегрузка оператора "!=" (не равно).
    # Метод '__ne__()' (Not Equal) определяет, что должно происходить при использовании оператора "!=".
    # В данном примере: проверяется, различаются ли значения атрибута 'number_of_floors' у двух объектов.
    def __ne__(self, other):
        if isinstance(other, House):
            return self.number_of_floors != other.number_of_floors

    # Перегрузка оператора "+" (сложение).
    # Метод '__add__()' (Addition) определяет, что должно происходить при использовании оператора "+".
    # В данном примере: добавляется целочисленное значение к атрибуту 'number_of_floors' текущего объекта.
    # Если переданный параметр не является целым числом, метод ничего не делает.
    def __add__(self, value):
        # Проверяем, является ли переданное значение целым числом.
        if isinstance(value, int):
            # Добавляем значение к атрибуту 'number_of_floors' текущего объекта.
            self.number_of_floors += value
            # Возвращаем текущий объект, чтобы можно было использовать результат в цепочке операций.
            return self

    # Перегрузка оператора "+" (сложение) с правым операндом.
    # Метод '__radd__()' вызывается, если объект класса находится справа от оператора "+".
    # В данном примере: если value является числом (int), то метод возвращает сумму атрибута 'number_of_floors' текущего объекта и value.
    # Использование: число + объект
    def __radd__(self, value):
        if isinstance(value, int):
            self.number_of_floors += value # Добавляем значение к атрибуту 'number_of_floors' текущего объекта.
            return self # возвращаем текущий объект

    # Перегрузка оператора "+=" (сложение с присваиванием).
    # Метод '__iadd__()' определяет поведение при использовании оператора "+=".
    # В данном примере: если value является числом (int), то метод изменяет значение атрибута 'number_of_floors' текущего объекта, увеличивая его на value.
    # После этого возвращает текущий объект (self), чтобы оператор "+=" работал корректно.
    # Использование: объект += число
    def __iadd__(self, value):
        if isinstance(value, int):
            self.number_of_floors += value  # Добавляем значение к атрибуту 'number_of_floors' текущего объекта.
            return self  # возвращаем текущий объект

    ### НЬАНСЫ ПРИ РАБОТЕ С АРИФМИТИЧЕСКИМИ ОПЕРАТОРАМИ  ###
    # Если ваша цель — Добавление значения к атрибуту объекта и изменение объекта:
    # def __add__(self, value):
    #     if isinstance(value, int):
    #         self.number_of_floors += value  # Сохраняем результат сложения в атрибуте
    #         return self  # Возвращаем текущий объект

    # Если ваша цель — Возвращение результата сложения, не изменяя объект:
    # def __add__(self, value):
    #     if isinstance(value, int):
    #         return self.number_of_floors + value  # Возвращаем результат сложения

    # ПРИМЕР ОСТАЛЬНЫХ АРИФМЕТИЧЕСКИХ ОПЕРАТОРОВ
            # ПРИЧМЕЧАНИЕ #
            # Да, если добавить i к названию метода
            # Использовать __iadd__ вместо __add__, это изменяет поведение оператора так, чтобы он работал как оператор присваивания с арифметикой (+=).
        # Перегрузка оператора "+" (сложение).
        # Метод '__add__()' определяет, что должно происходить при использовании оператора "+".
        # В данном примере: складываются значения атрибута 'атрибут' двух объектов.

        # Перегрузка оператора "-" (вычитание).
        # Метод '__sub__()' (Subtraction) определяет, что должно происходить при использовании оператора "-".
        # В данном примере: вычитается значение атрибута 'атрибут' одного объекта из другого.

        # Перегрузка оператора "*" (умножение).
        # Метод '__mul__()' (Multiplication) определяет, что должно происходить при использовании оператора "*".
        # В данном примере: значения атрибута 'атрибут' двух объектов перемножаются.

        # Перегрузка оператора "/" (деление).
        # Метод '__truediv__()' (True Division) определяет, что должно происходить при использовании оператора "/".
        # В данном примере: значение атрибута 'атрибут' одного объекта делится на значение другого.

        # Перегрузка оператора "//" (целочисленное деление).
        # Метод '__floordiv__()' (Floor Division) определяет, что должно происходить при использовании оператора "//".
        # В данном примере: выполняется целочисленное деление значений атрибута 'атрибут'.

        # Перегрузка оператора "%" (остаток от деления).
        # Метод '__mod__()' (Modulo) определяет, что должно происходить при использовании оператора "%".
        # В данном примере: вычисляется остаток от деления значений атрибута 'атрибут' двух объектов.

        # Перегрузка оператора "**" (возведение в степень).
        # Метод '__pow__()' (Power) определяет, что должно происходить при использовании оператора "**".
        # В данном примере: значение атрибута 'атрибут' одного объекта возводится в степень, равную значению другого.


h1 = House('ЖК Горский', 18)
h2 = House('Домик в деревне', 2)

print(f'{h1.name, h1.number_of_floors}') # я про этот принт
h1.go_to(10)
print(f'{h2.name, h2.number_of_floors}') # я про этот принт
h2.go_to(10)

# __str__
print(h1) # получаем srt представление об объекте # то есть принт выше мы можем не использовать, чтобы получить информацию, мы уже добавили метод, который это делает
print(h2) # получаем srt представление об объекте

# __len__
print(len(h1)) # len возвращает длину объекта (в данном случаи номер/длину этажей)
print(len(h2)) # len возвращает длину объекта (в данном случаи номер/длину этажей)

h1 = House('ЖК Эльбрус', 10)
h2 = House('ЖК Акация', 20)

print(h1)
print(h2)

print(h1 == h2) # __eq__

h1 = h1 + 10 # __add__
print(h1)
print(h1 == h2)

h1 += 10 # __iadd__
print(h1)

h2 = 10 + h2 # __radd__
print(h2)

print(h1 > h2) # __gt__
print(h1 >= h2) # __ge__
print(h1 < h2) # __lt__
print(h1 <= h2) # __le__
print(h1 != h2) # __ne__