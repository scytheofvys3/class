# Объектно-ориентированное программирование (ООП) основывается на трёх ключевых принципах:
# 1) Наследование — этот принцип позволяет создавать новые классы на основе существующих,
# что даёт возможность расширять и изменять поведение базового класса, делая производные классы более уникальными.
# 2) Инкапсуляция — позволяет скрывать внутренние детали реализации класса от пользователей,
# предоставляя доступ только к необходимым элементам. Это способствует более безопасной работе и предотвращает случайные ошибки.
# 3) Полиморфизм — позволяет использовать объекты разных классов через единый интерфейс,
# что упрощает взаимодействие с ними и делает код более гибким.
'''Дополнительное объяснение:'''
# Что такое класс?
# Класс — это конструкция, которая описывает структуру и поведение объектов. Он содержит:
#
# Атрибуты — данные или свойства объекта (например, name).
# Методы — функции, которые определяют поведение объекта.
# Что такое объект?
# Объект (или экземпляр класса) — это конкретный "представитель" класса с уникальным набором атрибутов. В данном примере Ilya и Alina — это два разных объекта класса Human.
#
# Что делает __init__?
# __init__ (инициализатор) автоматически вызывается при создании нового объекта. Он помогает задать начальные значения атрибутов, используя аргументы, переданные при создании объекта.
#
# Почему используется self?
#
# self — это ссылка на текущий объект, который создаётся.
# Все атрибуты и методы объекта доступны через self.
# В инициализаторе self.name = name означает: "Создать атрибут name у текущего объекта и присвоить ему значение из аргумента name."
# Для создания класса достаточно указать ключевое слово class, после которого следует название класса (с большой буквы).

# Класс можно представить как шаблон или инструкцию, на основе которой создаются объекты (экземпляры).
# Каждый объект класса обладает характеристиками (атрибутами) и может выполнять определённые действия (методы).
# Классы позволяют объединять данные (атрибуты) и логику (методы) в одной структуре.

class Human():
    # Инициализатор класса (__init__) — это специальный метод, который вызывается автоматически при создании нового объекта.
    # Он используется для задания начальных значений атрибутов объекта.
    def __init__(self, name, age):
        """Здесь обычно идет описание класса в тройных кавычках"""
        # self — ссылка на текущий экземпляр объекта. Она позволяет обращаться к атрибутам и методам объекта.
        # Атрибуты name и age инициализируются при создании объекта. Они становятся уникальными характеристиками каждого объекта.
        self.name = name # Устанавливаем значение атрибута name.
        self.age = age # Устанавливаем значение атрибута age.
        self.say_info()  # Вызов метода внутри конструктора (__init__). Это позволяет автоматически выводить информацию о созданном объекте.

    # Метод объекта, который выводит информацию об объекте в формате строки.
    def say_info(self):
        # self.name и self.age относятся к текущему экземпляру класса.
        print(f'Привет, меня зовут {self.name}, мне {self.age}')

    # Метод объекта, который увеличивает значение атрибута age на 1.
    def birthday(self): # метод при котором, использовании этого метода увеличивается возраст объекта/экземпляра
        self.age += 1 # Увеличиваем значение возраста (age) текущего объекта.
        print(f'У меня день рождения, мне теперь {self.age}')

    # Методы, содержащие двойное подчеркивание, называются специальными или магическими методами.
    # Также можно встретить другое название — dunder-методы, что является сокращением от фразы "double underscore"
    # (двойное нижнее подчеркивание). На данном занятии будет представлено несколько из этих магических методов.


    # Использование метода __len__() для определения длины массива в Python.
    # Метод __len__ всегда должен возвращать int
    def __len__(self):
        return self.age

    # destruct - деструктор
    # Это может происходить либо по завершении работы интерпретатора, когда все строки кода выполнены, либо при отсутствии ссылок на объект.
    # Для удаления объекта можно воспользоваться оператором '__del__', который активирует деструктор.
    def __del__(self):
        print(f'{self.name} ушел, но обещал(а) вернуться')




# ilya — это экземпляр (объект) класса Human.
# Переменная ilya — это объект (экземпляр) класса Human, созданный на основе его шаблона.
# Класс Human — это шаблон, описывающий свойства и поведение человека (атрибуты и методы).

# Чтобы создать объект, вы вызываете класс как функцию
# Создаём объект класса Human с именем 'Илья' и возрастом 24.
ilya = Human('Илья', 24)
# Переменная ilya представляет собой экземпляр класса Human и хранит информацию о конкретном человеке.

# Можно добавить атрибут объекту после его создания, даже если он не был определён в классе.
ilya.surname = 'Нефедов'

# Создаём второй объект класса Human с именем 'Алина' и возрастом 24.
alina = Human('Алина', 24)

# Выводим значения атрибутов объектов.
# Атрибут name хранит имя объекта, age — возраст, а surname был добавлен вручную для объекта ilya.
print(ilya.name, ilya.surname, ilya.age)
print(alina.name, alina.age)

# Функция hasattr() проверяет существование атрибута в указанном объекте.
if hasattr(ilya, 'surname'):
    print(f'{ilya.surname}, Проверка функции hasattr')
else:
    print("У объекта нет атрибута surname.")

# Применяем метод birthday для объекта alina, чтобы увеличить её возраст на 1.
alina.birthday()

# Вновь выводим информацию об объектах, используя метод say_info.
ilya.say_info()
alina.say_info()

# DZ 21
class House(): # создаем класс дома
    def __init__(self, name, number_of_floors): # инициализация. self - ссылка на саму себя, атрибуты: name - название, number_of_floors - номер этажа
        self.name = name # устанавливаем значение атрибута name = name
        self.number_of_floors = number_of_floors # устанавливаем значение атрибута number_of_floors = number_of_floors

    def go_to(self, new_floor): # метод в классе
        if new_floor > self.number_of_floors or new_floor < 1: # Если new_floor больше чем self.number_of_floors или меньше 1
            return print('Такого этажа не существует') # возвращаем Такого этажа не существует
        else: # иначе
            for i in range(1, new_floor + 1): # для(for) i в(in) range(1, new_floor + 1)
                                              # range(start, stop, step) - stop не включительный
                print (i)

    def __len__(self): # метод __len__ возвращает длину массива, всегда int
        return self.number_of_floors # возвращаем номер/длину этажей

    # Метод __str__ является специальным методом, предназначенным для представления строкового представления объекта.
    def __str__(self):
        return f'Название: {self.name}, кол-во этажей {self.number_of_floors}'

h1 = House('ЖК Горский', 18)
h2 = House('Домик в деревне', 2)

print(f'{h1.name, h1.number_of_floors}')
h1.go_to(10)
print(f'{h2.name, h2.number_of_floors}')
h2.go_to(10)

# __str__
print(h1) # получаем srt представление об объекте
print(h2) # получаем srt представление об объекте

# __len__
print(len(h1)) # len возвращает длину объекта (в данном случаи номер/длину этажей)
print(len(h2)) # len возвращает длину объекта (в данном случаи номер/длину этажей)