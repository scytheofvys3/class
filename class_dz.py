# DZ 21
class House:  # Создаем класс House (Дом)

    houses_history = []  # Атрибут класса House - пустой список, который будет хранить историю всех домов.

    # Метод __new__ — это специальный метод, который вызывается перед методом __init__.
    # Его задача — создать и вернуть новый объект.
    # Он принимает класс (cls) как первый аргумент, а также любые дополнительные аргументы,
    # переданные при создании объекта.
    # Важно, чтобы метод __new__ возвращал новый экземпляр класса, потому что этот экземпляр
    # затем будет передан в метод __init__ для инициализации.
    def __new__(cls, *args, **kwargs):
        cls.houses_history.append(args[0])  # Добавляем значение нулевого индекса из args (например, имя дома)
        # В этом случае предполагается, что первым аргументом будет имя дома.
        # Этот список хранит все дома, созданные с использованием класса House.

        # Вызов родительского метода __new__ у базового класса object.
        # Метод __new__ создаёт новый экземпляр объекта, который будет использоваться в программе.
        # Мы передаем управление методу __new__ родительского класса object для создания объекта.
        return object.__new__(cls)  # Создает новый экземпляр объекта, возвращая его.

    def __init__(self, name, number_of_floors): # инициализация. self - ссылка на саму себя, атрибуты: name - название, number_of_floors - номер этажа
        self.name = name # устанавливаем значение атрибута name = name
        self.number_of_floors = number_of_floors # устанавливаем значение атрибута number_of_floors = number_of_floors

    def go_to(self, new_floor): # метод в классе
        if new_floor > self.number_of_floors or new_floor < 1: # Если new_floor больше чем self.number_of_floors или меньше 1
            return print('Такого этажа не существует') # возвращаем Такого этажа не существует
        else: # иначе
            for i in range(1, new_floor + 1): # для(for) i в(in) range(1, new_floor + 1)
                                              # range(start, stop, step) - stop не включительный
                print (i)

    def __len__(self): # метод __len__ возвращает длину массива, всегда int
        return self.number_of_floors # возвращаем номер/длину этажей

    # Перегрузка оператора "str()" (представление объекта в виде строки).
    # Метод __str__ является специальным методом, предназначенным для представления строкового представления объекта.
    # Метод '__str__()' определяет, как объект будет выглядеть при вызове функции str() или print().
    def __str__(self):
        return f'Название: {self.name}, кол-во этажей {self.number_of_floors}'

    # Деструктор - уничтожение объекта.
    # Этот метод вызывается, когда объект уничтожается или когда на него больше не остаётся ссылок.
    def __del__(self):
        print(f'{self.name} снесен, но он останется в истории')
        # Здесь можно освободить ресурсы или выполнить другие действия перед уничтожением объекта.
        # Например, можно добавить запись в журнал или очистить какие-то внешние ресурсы.
        # Для заглушки можно использовать pass, если не требуется выполнять дополнительные действия.

    # Перезагрузка оператора "==" (равно).
    # Метод '__eq__()' (Equal) определяет, что должно происходить при использовании оператора "==" для объектов данного класса.
    # В данном примере: два объекта будут сравниваться на основе их атрибутов number_of_floors == number_of_floors
    # Функция isinstance() используется для проверки принадлежности объекта к определенному классу или типу данных.
    ## isinstance - (объект, (тип данных)) - выдает true(истина) или false(ложь)
    def __eq__(self, other):
        if isinstance(other, House):
            return self.number_of_floors == other.number_of_floors

    # Перегрузка оператора "<" (меньше чем).
    # Метод '__lt__()' (Lower Than) определяет, что должно происходить при использовании оператора "<" для объектов данного класса.
    # В данном примере: два объекта будут сравниваться на основе их атрибута 'age'
    def __lt__(self, other):
        if isinstance(other, House):
            return self.number_of_floors < other.number_of_floors

    # Перегрузка оператора "<=" (меньше или равно).
    # Метод '__le__()' (Lower or Equal) определяет, что должно происходить при использовании оператора "<=".
    # В данном примере: проверяется, меньше или равен атрибут 'age' у одного объекта по сравнению с другим.
    def __le__(self, other):
        if isinstance(other, House):
            return self.number_of_floors <= other.number_of_floors

    # Перегрузка оператора ">" (больше чем).
    # Метод '__gt__()' (Greater Than) определяет, что должно происходить при использовании оператора ">".
    # В данном примере: два объекта сравниваются на основе их атрибута 'number_of_floors', проверяя, больше ли он.
    def __gt__(self, other):
        if isinstance(other, House):
            return self.number_of_floors > other.number_of_floors

    # Перегрузка оператора ">=" (больше или равно).
    # Метод '__ge__()' (Greater or Equal) определяет, что должно происходить при использовании оператора ">=".
    # В данном примере: проверяется, больше или равен атрибут 'number_of_floors' у одного объекта по сравнению с другим.
    def __ge__(self, other):
        if isinstance(other, House):
            return self.number_of_floors >= other.number_of_floors

    # Перегрузка оператора "!=" (не равно).
    # Метод '__ne__()' (Not Equal) определяет, что должно происходить при использовании оператора "!=".
    # В данном примере: проверяется, различаются ли значения атрибута 'number_of_floors' у двух объектов.
    def __ne__(self, other):
        if isinstance(other, House):
            return self.number_of_floors != other.number_of_floors

    # Перегрузка оператора "+" (сложение).
    # Метод '__add__()' (Addition) определяет, что должно происходить при использовании оператора "+".
    # В данном примере: добавляется целочисленное значение к атрибуту 'number_of_floors' текущего объекта.
    # Если переданный параметр не является целым числом, метод ничего не делает.
    def __add__(self, value):
        # Проверяем, является ли переданное значение целым числом.
        if isinstance(value, int):
            # Добавляем значение к атрибуту 'number_of_floors' текущего объекта.
            self.number_of_floors += value
            # Возвращаем текущий объект, чтобы можно было использовать результат в цепочке операций.
            return self

    # Перегрузка оператора "+" (сложение) с правым операндом.
    # Метод '__radd__()' вызывается, если объект класса находится справа от оператора "+".
    # В данном примере: если value является числом (int), то метод возвращает сумму атрибута 'number_of_floors' текущего объекта и value.
    # Использование: число + объект
    def __radd__(self, value):
        if isinstance(value, int):
            self.number_of_floors += value # Добавляем значение к атрибуту 'number_of_floors' текущего объекта.
            return self # возвращаем текущий объект

    # Перегрузка оператора "+=" (сложение с присваиванием).
    # Метод '__iadd__()' определяет поведение при использовании оператора "+=".
    # В данном примере: если value является числом (int), то метод изменяет значение атрибута 'number_of_floors' текущего объекта, увеличивая его на value.
    # После этого возвращает текущий объект (self), чтобы оператор "+=" работал корректно.
    # Использование: объект += число
    def __iadd__(self, value):
        if isinstance(value, int):
            self.number_of_floors += value  # Добавляем значение к атрибуту 'number_of_floors' текущего объекта.
            return self  # возвращаем текущий объект

    ### НЬАНСЫ ПРИ РАБОТЕ С АРИФМИТИЧЕСКИМИ ОПЕРАТОРАМИ  ###
    # Если ваша цель — Добавление значения к атрибуту объекта и изменение объекта:
    # def __add__(self, value):
    #     if isinstance(value, int):
    #         self.number_of_floors += value  # Сохраняем результат сложения в атрибуте
    #         return self  # Возвращаем текущий объект

    # Если ваша цель — Возвращение результата сложения, не изменяя объект:
    # def __add__(self, value):
    #     if isinstance(value, int):
    #         return self.number_of_floors + value  # Возвращаем результат сложения

    # ПРИМЕР ОСТАЛЬНЫХ АРИФМЕТИЧЕСКИХ ОПЕРАТОРОВ
            # ПРИЧМЕЧАНИЕ #
            # Да, если добавить i к названию метода
            # Использовать __iadd__ вместо __add__, это изменяет поведение оператора так, чтобы он работал как оператор присваивания с арифметикой (+=).
        # Перегрузка оператора "+" (сложение).
        # Метод '__add__()' определяет, что должно происходить при использовании оператора "+".
        # В данном примере: складываются значения атрибута 'атрибут' двух объектов.

        # Перегрузка оператора "-" (вычитание).
        # Метод '__sub__()' (Subtraction) определяет, что должно происходить при использовании оператора "-".
        # В данном примере: вычитается значение атрибута 'атрибут' одного объекта из другого.

        # Перегрузка оператора "*" (умножение).
        # Метод '__mul__()' (Multiplication) определяет, что должно происходить при использовании оператора "*".
        # В данном примере: значения атрибута 'атрибут' двух объектов перемножаются.

        # Перегрузка оператора "/" (деление).
        # Метод '__truediv__()' (True Division) определяет, что должно происходить при использовании оператора "/".
        # В данном примере: значение атрибута 'атрибут' одного объекта делится на значение другого.

        # Перегрузка оператора "//" (целочисленное деление).
        # Метод '__floordiv__()' (Floor Division) определяет, что должно происходить при использовании оператора "//".
        # В данном примере: выполняется целочисленное деление значений атрибута 'атрибут'.

        # Перегрузка оператора "%" (остаток от деления).
        # Метод '__mod__()' (Modulo) определяет, что должно происходить при использовании оператора "%".
        # В данном примере: вычисляется остаток от деления значений атрибута 'атрибут' двух объектов.

        # Перегрузка оператора "**" (возведение в степень).
        # Метод '__pow__()' (Power) определяет, что должно происходить при использовании оператора "**".
        # В данном примере: значение атрибута 'атрибут' одного объекта возводится в степень, равную значению другого.


# h1 = House('ЖК Горский', 18)
# h2 = House('Домик в деревне', 2)
#
# print(f'{h1.name, h1.number_of_floors}') # я про этот принт
# h1.go_to(10)
# print(f'{h2.name, h2.number_of_floors}') # я про этот принт
# h2.go_to(10)

# __str__
# print(h1) # получаем srt представление об объекте # то есть принт выше мы можем не использовать, чтобы получить информацию, мы уже добавили метод, который это делает
# print(h2) # получаем srt представление об объекте
#
# # __len__
# print(len(h1)) # len возвращает длину объекта (в данном случаи номер/длину этажей)
# print(len(h2)) # len возвращает длину объекта (в данном случаи номер/длину этажей)
#
# h1 = House('ЖК Эльбрус', 10)
# h2 = House('ЖК Акация', 20)
#
# print(h1)
# print(h2)
#
# print(h1 == h2) # __eq__
#
# h1 = h1 + 10 # __add__
# print(h1)
# print(h1 == h2)
#
# h1 += 10 # __iadd__
# print(h1)
#
# h2 = 10 + h2 # __radd__
# print(h2)
#
# print(h1 > h2) # __gt__
# print(h1 >= h2) # __ge__
# print(h1 < h2) # __lt__
# print(h1 <= h2) # __le__
# print(h1 != h2) # __ne__

h1 = House('ЖК Эльбрус', 10)
print(House.houses_history)
h2 = House('ЖК Акация', 20)
print(House.houses_history)
h3 = House('ЖК Матрёшки', 20)
print(House.houses_history)

# Удаление объектов
del h2
del h3

print(House.houses_history)